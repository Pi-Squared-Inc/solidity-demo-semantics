<solidity>
  <k>
    .K
  </k>
  <summarize>
    false
  </summarize>
  <compile>
    <current-body>
      UniswapV2SwapTest
    </current-body>
    <ifaces>
      <iface>
        <iface-id>
          IERC20
        </iface-id>
        <iface-fns>
          <iface-fn>
            <iface-fn-id>
              approve
            </iface-fn-id>
            <iface-fn-arg-types>
              ListItem ( address )
              ListItem ( uint256 )
            </iface-fn-arg-types>
            <iface-fn-return-types>
              ListItem ( bool )
            </iface-fn-return-types>
          </iface-fn> <iface-fn>
            <iface-fn-id>
              balanceOf
            </iface-fn-id>
            <iface-fn-arg-types>
              ListItem ( address )
            </iface-fn-arg-types>
            <iface-fn-return-types>
              ListItem ( uint256 )
            </iface-fn-return-types>
          </iface-fn> <iface-fn>
            <iface-fn-id>
              transfer
            </iface-fn-id>
            <iface-fn-arg-types>
              ListItem ( address )
              ListItem ( uint256 )
            </iface-fn-arg-types>
            <iface-fn-return-types>
              ListItem ( bool )
            </iface-fn-return-types>
          </iface-fn> <iface-fn>
            <iface-fn-id>
              transferFrom
            </iface-fn-id>
            <iface-fn-arg-types>
              ListItem ( address )
              ListItem ( address )
              ListItem ( uint256 )
            </iface-fn-arg-types>
            <iface-fn-return-types>
              ListItem ( bool )
            </iface-fn-return-types>
          </iface-fn>
        </iface-fns>
      </iface>
    </ifaces>
    <contracts>
      <contract>
        <contract-id>
          DAIMock
        </contract-id>
        <contract-state>
          UINT_MAX |-> uint256
          allowance |-> mapping ( address  => mapping ( address  => uint256  )  )
          balanceOf |-> mapping ( address  => uint256  )
          totalSupply |-> uint256
        </contract-state>
        <contract-init>
          ListItem ( UINT_MAX = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ; )
        </contract-init>
        <contract-fns>
          <contract-fn>
            <contract-fn-id>
              allowance
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( address )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( $0 )
              ListItem ( $1 )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( mapping ( address  => mapping ( address  => uint256  )  ) )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              return allowance [ $0 ] [ $1 ] ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              approve
            </contract-fn-id>
            <contract-fn-visibility>
              external
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( usr )
              ListItem ( wad )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( bool )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              allowance [ msg . sender ] [ usr ] = wad ;  emit Approval ( msg . sender , usr , wad , .TypedVals ) ;  return true ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              balanceOf
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( $0 )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( mapping ( address  => uint256  ) )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              return balanceOf [ $0 ] ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              burn
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( usr )
              ListItem ( wad )
            </contract-fn-param-names>
            <contract-fn-return-types>
              .List
            </contract-fn-return-types>
            <contract-fn-return-names>
              .List
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              if ( balanceOf [ usr ] >= wad ) { balanceOf [ usr ] = balanceOf [ usr ] - wad ;  totalSupply = totalSupply - wad ;  .Statements }  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              decimals
            </contract-fn-id>
            <contract-fn-visibility>
              external
            </contract-fn-visibility>
            <contract-fn-arg-types>
              .List
            </contract-fn-arg-types>
            <contract-fn-param-names>
              .List
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint8 )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              return 18 ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              mint
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( usr )
              ListItem ( wad )
            </contract-fn-param-names>
            <contract-fn-return-types>
              .List
            </contract-fn-return-types>
            <contract-fn-return-names>
              .List
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              balanceOf [ usr ] = balanceOf [ usr ] + wad ;  totalSupply = totalSupply + wad ;  emit Transfer ( address ( 0 , .TypedVals ) , usr , wad , .TypedVals ) ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              mintOnDeposit
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( usr )
              ListItem ( wad )
            </contract-fn-param-names>
            <contract-fn-return-types>
              .List
            </contract-fn-return-types>
            <contract-fn-return-names>
              .List
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              mint ( usr , wad , .TypedVals ) ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              safeTransferFrom
            </contract-fn-id>
            <contract-fn-visibility>
              external
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( address )
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( from )
              ListItem ( to )
              ListItem ( value )
            </contract-fn-param-names>
            <contract-fn-return-types>
              .List
            </contract-fn-return-types>
            <contract-fn-return-names>
              .List
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              transferFrom ( from , to , value , .TypedVals ) ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              totalSupply
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              .List
            </contract-fn-arg-types>
            <contract-fn-param-names>
              .List
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint256 )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              return totalSupply ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              transfer
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( dst )
              ListItem ( wad )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( bool )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              return transferFrom ( msg . sender , dst , wad , .TypedVals ) ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              transferFrom
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( address )
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( src )
              ListItem ( dst )
              ListItem ( wad )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( bool )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              require ( balanceOf [ src ] >= wad , "Dai/insufficient-balance" , .TypedVals ) ;  if ( src != msg . sender && allowance [ src ] [ msg . sender ] != UINT_MAX ) { require ( allowance [ src ] [ msg . sender ] >= wad , "Dai/insufficient-allowance" , .TypedVals ) ;  allowance [ src ] [ msg . sender ] = allowance [ src ] [ msg . sender ] - wad ;  .Statements }  balanceOf [ src ] = balanceOf [ src ] - wad ;  balanceOf [ dst ] = balanceOf [ dst ] + wad ;  emit Transfer ( src , dst , wad , .TypedVals ) ;  return true ;  .Statements
            </contract-fn-body>
          </contract-fn>
        </contract-fns>
        <contract-events>
          <contract-event>
            <contract-event-id>
              Approval
            </contract-event-id>
            <contract-event-arg-types>
              ListItem ( address )
              ListItem ( address )
              ListItem ( uint256 )
            </contract-event-arg-types>
            <contract-event-param-names>
              ListItem ( src )
              ListItem ( guy )
              ListItem ( wad )
            </contract-event-param-names>
            <contract-event-indexed-pos>
              SetItem ( 0 )
              SetItem ( 1 )
            </contract-event-indexed-pos>
          </contract-event> <contract-event>
            <contract-event-id>
              Transfer
            </contract-event-id>
            <contract-event-arg-types>
              ListItem ( address )
              ListItem ( address )
              ListItem ( uint256 )
            </contract-event-arg-types>
            <contract-event-param-names>
              ListItem ( src )
              ListItem ( dst )
              ListItem ( wad )
            </contract-event-param-names>
            <contract-event-indexed-pos>
              SetItem ( 0 )
              SetItem ( 1 )
            </contract-event-indexed-pos>
          </contract-event>
        </contract-events>
      </contract> <contract>
        <contract-id>
          USDCMock
        </contract-id>
        <contract-state>
          UINT256_MAX |-> uint256
          _allowances |-> mapping ( address account => mapping ( address spender => uint256  )  )
          _balances |-> mapping ( address account => uint256  )
          _totalSupply |-> uint256
        </contract-state>
        <contract-init>
          ListItem ( UINT256_MAX = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ; )
        </contract-init>
        <contract-fns>
          <contract-fn>
            <contract-fn-id>
              _approve
            </contract-fn-id>
            <contract-fn-visibility>
              private
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( address )
              ListItem ( uint256 )
              ListItem ( bool )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( owner )
              ListItem ( spender )
              ListItem ( value )
              ListItem ( emitEvent )
            </contract-fn-param-names>
            <contract-fn-return-types>
              .List
            </contract-fn-return-types>
            <contract-fn-return-names>
              .List
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              require ( owner != address ( 0 , .TypedVals ) , "USDC: invalid approver" , .TypedVals ) ;  require ( spender != address ( 0 , .TypedVals ) , "USDC: invalid spender" , .TypedVals ) ;  _allowances [ owner ] [ spender ] = value ;  if ( emitEvent ) { emit Approval ( owner , spender , value , .TypedVals ) ;  .Statements }  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              _spendAllowance
            </contract-fn-id>
            <contract-fn-visibility>
              private
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( address )
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( owner )
              ListItem ( spender )
              ListItem ( value )
            </contract-fn-param-names>
            <contract-fn-return-types>
              .List
            </contract-fn-return-types>
            <contract-fn-return-names>
              .List
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              uint256 currentAllowance = allowance ( owner , spender , .TypedVals ) ;  if ( currentAllowance != UINT256_MAX ) { require ( currentAllowance >= value , "USDC: insufficient allowance" , .TypedVals ) ;  _approve ( owner , spender , currentAllowance - value , false , .TypedVals ) ;  .Statements }  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              _transfer
            </contract-fn-id>
            <contract-fn-visibility>
              private
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( address )
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( from )
              ListItem ( to )
              ListItem ( value )
            </contract-fn-param-names>
            <contract-fn-return-types>
              .List
            </contract-fn-return-types>
            <contract-fn-return-names>
              .List
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              require ( from != address ( 0 , .TypedVals ) , "USDC: invalid sender" , .TypedVals ) ;  require ( to != address ( 0 , .TypedVals ) , "USDC: invalid receiver" , .TypedVals ) ;  _update ( from , to , value , .TypedVals ) ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              _update
            </contract-fn-id>
            <contract-fn-visibility>
              private
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( address )
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( from )
              ListItem ( to )
              ListItem ( value )
            </contract-fn-param-names>
            <contract-fn-return-types>
              .List
            </contract-fn-return-types>
            <contract-fn-return-names>
              .List
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              if ( from == address ( 0 , .TypedVals ) ) { _totalSupply = _totalSupply + value ;  .Statements } else { uint256 fromBalance = _balances [ from ] ;  require ( fromBalance >= value , "USDC: insufficient balance" , .TypedVals ) ;  _balances [ from ] = fromBalance - value ;  .Statements }  if ( to == address ( 0 , .TypedVals ) ) { _totalSupply = _totalSupply - value ;  .Statements } else { _balances [ to ] = _balances [ to ] + value ;  .Statements }  emit Transfer ( from , to , value , .TypedVals ) ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              allowance
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( address )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( owner )
              ListItem ( spender )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint256 )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              return _allowances [ owner ] [ spender ] ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              approve
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( spender )
              ListItem ( value )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( bool )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              address owner = msg . sender ;  _approve ( owner , spender , value , true , .TypedVals ) ;  return true ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              balanceOf
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( account )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint256 )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              return _balances [ account ] ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              decimals
            </contract-fn-id>
            <contract-fn-visibility>
              external
            </contract-fn-visibility>
            <contract-fn-arg-types>
              .List
            </contract-fn-arg-types>
            <contract-fn-param-names>
              .List
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint8 )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              return 18 ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              mint
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( account )
              ListItem ( value )
            </contract-fn-param-names>
            <contract-fn-return-types>
              .List
            </contract-fn-return-types>
            <contract-fn-return-names>
              .List
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              require ( account != address ( 0 , .TypedVals ) , "USDC: invalid receiver" , .TypedVals ) ;  _update ( address ( 0 , .TypedVals ) , account , value , .TypedVals ) ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              transfer
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( to )
              ListItem ( value )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( bool )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              address owner = msg . sender ;  _transfer ( owner , to , value , .TypedVals ) ;  return true ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              transferFrom
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( address )
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( from )
              ListItem ( to )
              ListItem ( value )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( bool )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              address spender = msg . sender ;  _spendAllowance ( from , spender , value , .TypedVals ) ;  _transfer ( from , to , value , .TypedVals ) ;  return true ;  .Statements
            </contract-fn-body>
          </contract-fn>
        </contract-fns>
        <contract-events>
          <contract-event>
            <contract-event-id>
              Approval
            </contract-event-id>
            <contract-event-arg-types>
              ListItem ( address )
              ListItem ( address )
              ListItem ( uint256 )
            </contract-event-arg-types>
            <contract-event-param-names>
              ListItem ( owner )
              ListItem ( spender )
              ListItem ( value )
            </contract-event-param-names>
            <contract-event-indexed-pos>
              SetItem ( 0 )
              SetItem ( 1 )
            </contract-event-indexed-pos>
          </contract-event> <contract-event>
            <contract-event-id>
              Transfer
            </contract-event-id>
            <contract-event-arg-types>
              ListItem ( address )
              ListItem ( address )
              ListItem ( uint256 )
            </contract-event-arg-types>
            <contract-event-param-names>
              ListItem ( from )
              ListItem ( to )
              ListItem ( value )
            </contract-event-param-names>
            <contract-event-indexed-pos>
              SetItem ( 0 )
              SetItem ( 1 )
            </contract-event-indexed-pos>
          </contract-event>
        </contract-events>
      </contract> <contract>
        <contract-id>
          UniswapV2Pair
        </contract-id>
        <contract-state>
          MINIMUM_LIQUIDITY |-> uint256
          UINT112_MAX |-> uint256
          balanceOf |-> mapping ( address  => uint256  )
          blockTimestampLast |-> uint32
          kLast |-> uint256
          price0CumulativeLast |-> uint256
          price1CumulativeLast |-> uint256
          reserve0 |-> uint112
          reserve1 |-> uint112
          token0 |-> address
          token1 |-> address
          totalSupply |-> uint256
        </contract-state>
        <contract-init>
          ListItem ( UINT112_MAX = 0xffffffffffffffffffffffffffff ; )
          ListItem ( MINIMUM_LIQUIDITY = 10 ** 3 ; )
        </contract-init>
        <contract-fns>
          <contract-fn>
            <contract-fn-id>
              MINIMUM_LIQUIDITY
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              .List
            </contract-fn-arg-types>
            <contract-fn-param-names>
              .List
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint256 )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              return MINIMUM_LIQUIDITY ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              _update
            </contract-fn-id>
            <contract-fn-visibility>
              private
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( uint256 )
              ListItem ( uint256 )
              ListItem ( uint112 )
              ListItem ( uint112 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( balance0 )
              ListItem ( balance1 )
              ListItem ( _reserve0 )
              ListItem ( _reserve1 )
            </contract-fn-param-names>
            <contract-fn-return-types>
              .List
            </contract-fn-return-types>
            <contract-fn-return-names>
              .List
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              require ( balance0 <= UINT112_MAX && balance1 <= UINT112_MAX , "UniswapV2: OVERFLOW" , .TypedVals ) ;  uint32 blockTimestamp = uint32 ( block . timestamp % 2 ** 32 , .TypedVals ) ;  uint32 timeElapsed = blockTimestamp - blockTimestampLast ;  if ( timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0 ) { price0CumulativeLast = price0CumulativeLast + _reserve1 / _reserve0 * timeElapsed ;  price1CumulativeLast = price1CumulativeLast + _reserve0 / _reserve1 * timeElapsed ;  .Statements }  reserve0 = uint112 ( balance0 , .TypedVals ) ;  reserve1 = uint112 ( balance1 , .TypedVals ) ;  blockTimestampLast = blockTimestamp ;  emit Sync ( reserve0 , reserve1 , .TypedVals ) ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              balanceOf
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( $0 )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( mapping ( address  => uint256  ) )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              return balanceOf [ $0 ] ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              constructor
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( address )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( _token0 )
              ListItem ( _token1 )
            </contract-fn-param-names>
            <contract-fn-return-types>
              .List
            </contract-fn-return-types>
            <contract-fn-return-names>
              .List
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              token0 = _token0 ;  token1 = _token1 ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              getReserves
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              .List
            </contract-fn-arg-types>
            <contract-fn-param-names>
              .List
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint112 [ ] )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( reserves )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              reserves = new uint112 [ ] ( 3 , .TypedVals ) ;  reserves [ 0 ] = reserve0 ;  reserves [ 1 ] = reserve1 ;  reserves [ 2 ] = blockTimestampLast ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              kLast
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              .List
            </contract-fn-arg-types>
            <contract-fn-param-names>
              .List
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint256 )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              return kLast ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              math_min
            </contract-fn-id>
            <contract-fn-visibility>
              internal
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( uint256 )
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( x )
              ListItem ( y )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint256 )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( z )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              z = x < y ? x : y ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              math_sqrt
            </contract-fn-id>
            <contract-fn-visibility>
              internal
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( y )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint256 )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( z )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              if ( y > 3 ) { z = y ;  uint256 x = y / 2 + 1 ;  while ( x < z ) { z = x ;  x = ( y / x + x ) / 2 ;  .Statements }  .Statements } else if ( y != 0 ) { z = 1 ;  .Statements }  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              mint
            </contract-fn-id>
            <contract-fn-visibility>
              external
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( to )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint256 )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( liquidity )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              uint112 [ ] memory pair_reserves = getReserves ( .TypedVals ) ;  uint256 balance0 = IERC20 ( token0 , .TypedVals ) . balanceOf ( address ( this , .TypedVals ) , .TypedVals ) ;  uint256 balance1 = IERC20 ( token1 , .TypedVals ) . balanceOf ( address ( this , .TypedVals ) , .TypedVals ) ;  uint256 amount0 = balance0 - pair_reserves [ 0 ] ;  uint256 amount1 = balance1 - pair_reserves [ 1 ] ;  uint256 _totalSupply = totalSupply ;  if ( _totalSupply == 0 ) { liquidity = math_sqrt ( amount0 * amount1 , .TypedVals ) - MINIMUM_LIQUIDITY ;  totalSupply = totalSupply + MINIMUM_LIQUIDITY ;  balanceOf [ address ( 0 , .TypedVals ) ] = balanceOf [ address ( 0 , .TypedVals ) ] + MINIMUM_LIQUIDITY ;  .Statements } else { liquidity = math_min ( amount0 * _totalSupply / pair_reserves [ 0 ] , amount1 * _totalSupply / pair_reserves [ 1 ] , .TypedVals ) ;  .Statements }  require ( liquidity > 0 , "UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED" , .TypedVals ) ;  totalSupply = totalSupply + liquidity ;  balanceOf [ to ] = balanceOf [ to ] + liquidity ;  _update ( balance0 , balance1 , pair_reserves [ 0 ] , pair_reserves [ 1 ] , .TypedVals ) ;  emit Mint ( msg . sender , amount0 , amount1 , .TypedVals ) ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              price0CumulativeLast
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              .List
            </contract-fn-arg-types>
            <contract-fn-param-names>
              .List
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint256 )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              return price0CumulativeLast ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              price1CumulativeLast
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              .List
            </contract-fn-arg-types>
            <contract-fn-param-names>
              .List
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint256 )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              return price1CumulativeLast ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              swap
            </contract-fn-id>
            <contract-fn-visibility>
              external
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( uint256 )
              ListItem ( uint256 )
              ListItem ( address )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( amount0Out )
              ListItem ( amount1Out )
              ListItem ( to )
            </contract-fn-param-names>
            <contract-fn-return-types>
              .List
            </contract-fn-return-types>
            <contract-fn-return-names>
              .List
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              require ( amount0Out > 0 || amount1Out > 0 , "UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT" , .TypedVals ) ;  uint112 [ ] memory reserves = getReserves ( .TypedVals ) ;  require ( amount0Out < reserves [ 0 ] && amount1Out < reserves [ 1 ] , "UniswapV2: INSUFFICIENT_LIQUIDITY" , .TypedVals ) ;  uint256 balance0 ;  uint256 balance1 ;  { address _token0 = token0 ;  address _token1 = token1 ;  require ( to != _token0 && to != _token1 , "UniswapV2: INVALID_TO" , .TypedVals ) ;  if ( amount0Out > 0 ) IERC20 ( _token0 , .TypedVals ) . transfer ( to , amount0Out , .TypedVals ) ;  if ( amount1Out > 0 ) IERC20 ( _token1 , .TypedVals ) . transfer ( to , amount1Out , .TypedVals ) ;  balance0 = IERC20 ( _token0 , .TypedVals ) . balanceOf ( address ( this , .TypedVals ) , .TypedVals ) ;  balance1 = IERC20 ( _token1 , .TypedVals ) . balanceOf ( address ( this , .TypedVals ) , .TypedVals ) ;  .Statements }  uint256 amount0In = balance0 > reserves [ 0 ] - amount0Out ? balance0 - ( reserves [ 0 ] - amount0Out ) : 0 ;  uint256 amount1In = balance1 > reserves [ 1 ] - amount1Out ? balance1 - ( reserves [ 1 ] - amount1Out ) : 0 ;  require ( amount0In > 0 || amount1In > 0 , "UniswapV2: INSUFFICIENT_INPUT_AMOUNT" , .TypedVals ) ;  { uint256 balance0Adjusted = balance0 * 1000 - amount0In * 3 ;  uint256 balance1Adjusted = balance1 * 1000 - amount1In * 3 ;  require ( balance0Adjusted * balance1Adjusted >= uint256 ( reserves [ 0 ] , .TypedVals ) * reserves [ 1 ] * 1000 ** 2 , "UniswapV2: K" , .TypedVals ) ;  .Statements }  _update ( balance0 , balance1 , reserves [ 0 ] , reserves [ 1 ] , .TypedVals ) ;  emit Swap ( msg . sender , amount0In , amount1In , amount0Out , amount1Out , to , .TypedVals ) ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              sync
            </contract-fn-id>
            <contract-fn-visibility>
              external
            </contract-fn-visibility>
            <contract-fn-arg-types>
              .List
            </contract-fn-arg-types>
            <contract-fn-param-names>
              .List
            </contract-fn-param-names>
            <contract-fn-return-types>
              .List
            </contract-fn-return-types>
            <contract-fn-return-names>
              .List
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              _update ( IERC20 ( token0 , .TypedVals ) . balanceOf ( address ( this , .TypedVals ) , .TypedVals ) , IERC20 ( token1 , .TypedVals ) . balanceOf ( address ( this , .TypedVals ) , .TypedVals ) , reserve0 , reserve1 , .TypedVals ) ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              token0
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              .List
            </contract-fn-arg-types>
            <contract-fn-param-names>
              .List
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( address )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              return token0 ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              token1
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              .List
            </contract-fn-arg-types>
            <contract-fn-param-names>
              .List
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( address )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              return token1 ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              totalSupply
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              .List
            </contract-fn-arg-types>
            <contract-fn-param-names>
              .List
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint256 )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              return totalSupply ;  .Statements
            </contract-fn-body>
          </contract-fn>
        </contract-fns>
        <contract-events>
          <contract-event>
            <contract-event-id>
              Mint
            </contract-event-id>
            <contract-event-arg-types>
              ListItem ( address )
              ListItem ( uint256 )
              ListItem ( uint256 )
            </contract-event-arg-types>
            <contract-event-param-names>
              ListItem ( sender )
              ListItem ( amount0 )
              ListItem ( amount1 )
            </contract-event-param-names>
            <contract-event-indexed-pos>
              SetItem ( 0 )
            </contract-event-indexed-pos>
          </contract-event> <contract-event>
            <contract-event-id>
              Swap
            </contract-event-id>
            <contract-event-arg-types>
              ListItem ( address )
              ListItem ( uint256 )
              ListItem ( uint256 )
              ListItem ( uint256 )
              ListItem ( uint256 )
              ListItem ( address )
            </contract-event-arg-types>
            <contract-event-param-names>
              ListItem ( sender )
              ListItem ( amount0In )
              ListItem ( amount1In )
              ListItem ( amount0Out )
              ListItem ( amount1Out )
              ListItem ( to )
            </contract-event-param-names>
            <contract-event-indexed-pos>
              SetItem ( 0 )
              SetItem ( 5 )
            </contract-event-indexed-pos>
          </contract-event> <contract-event>
            <contract-event-id>
              Sync
            </contract-event-id>
            <contract-event-arg-types>
              ListItem ( uint112 )
              ListItem ( uint112 )
            </contract-event-arg-types>
            <contract-event-param-names>
              ListItem ( reserve0 )
              ListItem ( reserve1 )
            </contract-event-param-names>
            <contract-event-indexed-pos>
              .Set
            </contract-event-indexed-pos>
          </contract-event>
        </contract-events>
      </contract> <contract>
        <contract-id>
          UniswapV2Router02
        </contract-id>
        <contract-state>
          local_pairs |-> mapping ( address  => mapping ( address  => address  )  )
        </contract-state>
        <contract-init>
          .List
        </contract-init>
        <contract-fns>
          <contract-fn>
            <contract-fn-id>
              _addLiquidity
            </contract-fn-id>
            <contract-fn-visibility>
              internal
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( address )
              ListItem ( uint256 )
              ListItem ( uint256 )
              ListItem ( uint256 )
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( tokenA )
              ListItem ( tokenB )
              ListItem ( amountADesired )
              ListItem ( amountBDesired )
              ListItem ( amountAMin )
              ListItem ( amountBMin )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint256 [ ] )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( amounts )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              amounts = new uint256 [ ] ( 2 , .TypedVals ) ;  require ( get_local_pair ( tokenA , tokenB , .TypedVals ) != address ( 0 , .TypedVals ) , .TypedVals ) ;  uint256 [ ] memory reserves = uniswapV2Library_getReserves ( tokenA , tokenB , .TypedVals ) ;  if ( reserves [ 0 ] == 0 && reserves [ 1 ] == 0 ) { amounts [ 0 ] = amountADesired ;  amounts [ 1 ] = amountBDesired ;  .Statements } else { uint256 amountBOptimal = uniswapV2Library_quote ( amountADesired , reserves [ 0 ] , reserves [ 1 ] , .TypedVals ) ;  if ( amountBOptimal <= amountBDesired ) { require ( amountBOptimal >= amountBMin , "UniswapV2Router: INSUFFICIENT_B_AMOUNT" , .TypedVals ) ;  amounts [ 0 ] = amountADesired ;  amounts [ 1 ] = amountBOptimal ;  .Statements } else { uint256 amountAOptimal = uniswapV2Library_quote ( amountBDesired , reserves [ 1 ] , reserves [ 0 ] , .TypedVals ) ;  assert ( amountAOptimal <= amountADesired , .TypedVals ) ;  require ( amountAOptimal >= amountAMin , "UniswapV2Router: INSUFFICIENT_A_AMOUNT" , .TypedVals ) ;  amounts [ 0 ] = amountAOptimal ;  amounts [ 1 ] = amountBDesired ;  .Statements }  .Statements }  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              _swap
            </contract-fn-id>
            <contract-fn-visibility>
              private
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( uint256 [ ] )
              ListItem ( address [ ] )
              ListItem ( address )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( amounts )
              ListItem ( path )
              ListItem ( _to )
            </contract-fn-param-names>
            <contract-fn-return-types>
              .List
            </contract-fn-return-types>
            <contract-fn-return-names>
              .List
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              { uint256 i ;  while ( i < path . length - 1 ) { { address input = path [ i ] ;  address output = path [ i + 1 ] ;  address [ ] memory tokens = uniswapV2Library_sortTokens ( input , output , .TypedVals ) ;  uint256 amountOut = amounts [ i + 1 ] ;  uint256 amount0Out = input == tokens [ 0 ] ? uint256 ( 0 , .TypedVals ) : amountOut ;  uint256 amount1Out = input == tokens [ 0 ] ? amountOut : uint256 ( 0 , .TypedVals ) ;  address to = i < path . length - 2 ? uniswapV2Library_pairFor ( output , path [ i + 2 ] , .TypedVals ) : _to ;  UniswapV2Pair ( uniswapV2Library_pairFor ( input , output , .TypedVals ) , .TypedVals ) . swap ( amount0Out , amount1Out , to , .TypedVals ) ;  .Statements }  i ++ ;  .Statements }  .Statements }  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              addLiquidity
            </contract-fn-id>
            <contract-fn-visibility>
              external
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( address )
              ListItem ( uint256 )
              ListItem ( uint256 )
              ListItem ( uint256 )
              ListItem ( uint256 )
              ListItem ( address )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( tokenA )
              ListItem ( tokenB )
              ListItem ( amountADesired )
              ListItem ( amountBDesired )
              ListItem ( amountAMin )
              ListItem ( amountBMin )
              ListItem ( to )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint256 [ ] )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( amounts_liq )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              amounts_liq = new uint256 [ ] ( 3 , .TypedVals ) ;  uint256 [ ] memory amounts = _addLiquidity ( tokenA , tokenB , amountADesired , amountBDesired , amountAMin , amountBMin , .TypedVals ) ;  amounts_liq [ 0 ] = amounts [ 0 ] ;  amounts_liq [ 1 ] = amounts [ 1 ] ;  address pair = uniswapV2Library_pairFor ( tokenA , tokenB , .TypedVals ) ;  IERC20 ( tokenA , .TypedVals ) . transferFrom ( msg . sender , pair , amounts [ 0 ] , .TypedVals ) ;  IERC20 ( tokenB , .TypedVals ) . transferFrom ( msg . sender , pair , amounts [ 1 ] , .TypedVals ) ;  amounts_liq [ 2 ] = UniswapV2Pair ( pair , .TypedVals ) . mint ( to , .TypedVals ) ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              get_local_pair
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( address )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( tokenA )
              ListItem ( tokenB )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( address )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( pair )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              address [ ] memory tokens = uniswapV2Library_sortTokens ( tokenA , tokenB , .TypedVals ) ;  pair = local_pairs [ tokens [ 0 ] ] [ tokens [ 1 ] ] ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              local_pairs
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( address )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( $0 )
              ListItem ( $1 )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( mapping ( address  => mapping ( address  => address  )  ) )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              return local_pairs [ $0 ] [ $1 ] ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              set_local_pair
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( address )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( tokenA )
              ListItem ( tokenB )
            </contract-fn-param-names>
            <contract-fn-return-types>
              .List
            </contract-fn-return-types>
            <contract-fn-return-names>
              .List
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              address [ ] memory tokens = uniswapV2Library_sortTokens ( tokenA , tokenB , .TypedVals ) ;  local_pairs [ tokens [ 0 ] ] [ tokens [ 1 ] ] = address ( new UniswapV2Pair ( address ( tokens [ 0 ] , .TypedVals ) , address ( tokens [ 1 ] , .TypedVals ) , .TypedVals ) , .TypedVals ) ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              swapExactTokensForTokens
            </contract-fn-id>
            <contract-fn-visibility>
              external
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( uint256 )
              ListItem ( uint256 )
              ListItem ( address [ ] )
              ListItem ( address )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( amountIn )
              ListItem ( amountOutMin )
              ListItem ( path )
              ListItem ( to )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint256 [ ] )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( amounts )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              amounts = uniswapV2Library_getAmountsOut ( amountIn , path , .TypedVals ) ;  require ( amounts [ amounts . length - 1 ] >= amountOutMin , "UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT" , .TypedVals ) ;  IERC20 ( path [ 0 ] , .TypedVals ) . transferFrom ( msg . sender , uniswapV2Library_pairFor ( path [ 0 ] , path [ 1 ] , .TypedVals ) , amounts [ 0 ] , .TypedVals ) ;  _swap ( amounts , path , to , .TypedVals ) ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              swapTokensForExactTokens
            </contract-fn-id>
            <contract-fn-visibility>
              external
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( uint256 )
              ListItem ( uint256 )
              ListItem ( address [ ] )
              ListItem ( address )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( amountOut )
              ListItem ( amountInMax )
              ListItem ( path )
              ListItem ( to )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint256 [ ] )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( amounts )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              amounts = uniswapV2Library_getAmountsIn ( amountOut , path , .TypedVals ) ;  require ( amounts [ 0 ] <= amountInMax , "UniswapV2Router: EXCESSIVE_INPUT_AMOUNT" , .TypedVals ) ;  IERC20 ( path [ 0 ] , .TypedVals ) . transferFrom ( msg . sender , uniswapV2Library_pairFor ( path [ 0 ] , path [ 1 ] , .TypedVals ) , amounts [ 0 ] , .TypedVals ) ;  _swap ( amounts , path , to , .TypedVals ) ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              sync_local_pair
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( address )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( tokenA )
              ListItem ( tokenB )
            </contract-fn-param-names>
            <contract-fn-return-types>
              .List
            </contract-fn-return-types>
            <contract-fn-return-names>
              .List
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              address [ ] memory tokens = uniswapV2Library_sortTokens ( tokenA , tokenB , .TypedVals ) ;  UniswapV2Pair ( local_pairs [ tokens [ 0 ] ] [ tokens [ 1 ] ] , .TypedVals ) . sync ( .TypedVals ) ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              uniswapV2Library_getAmountIn
            </contract-fn-id>
            <contract-fn-visibility>
              private
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( uint256 )
              ListItem ( uint256 )
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( amountOut )
              ListItem ( reserveIn )
              ListItem ( reserveOut )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint256 )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( amountIn )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              require ( amountOut > 0 , "UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT" , .TypedVals ) ;  require ( reserveIn > 0 && reserveOut > 0 , "UniswapV2Library: INSUFFICIENT_LIQUIDITY" , .TypedVals ) ;  uint256 numerator = reserveIn * amountOut * 1000 ;  uint256 denominator = ( reserveOut - amountOut ) * 997 ;  amountIn = denominator != 0 ? numerator / denominator + 1 : 1 ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              uniswapV2Library_getAmountOut
            </contract-fn-id>
            <contract-fn-visibility>
              private
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( uint256 )
              ListItem ( uint256 )
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( amountIn )
              ListItem ( reserveIn )
              ListItem ( reserveOut )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint256 )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( amountOut )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              require ( amountIn > 0 , "UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT" , .TypedVals ) ;  require ( reserveIn > 0 && reserveOut > 0 , "UniswapV2Library: INSUFFICIENT_LIQUIDITY" , .TypedVals ) ;  uint256 amountInWithFee = amountIn * 997 ;  uint256 numerator = amountInWithFee * reserveOut ;  uint256 denominator = reserveIn * 1000 + amountInWithFee ;  amountOut = numerator / denominator ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              uniswapV2Library_getAmountsIn
            </contract-fn-id>
            <contract-fn-visibility>
              private
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( uint256 )
              ListItem ( address [ ] )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( amountOut )
              ListItem ( path )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint256 [ ] )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( amounts )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              require ( path . length >= 2 , "UniswapV2Library: INVALID_PATH" , .TypedVals ) ;  amounts = new uint256 [ ] ( path . length , .TypedVals ) ;  amounts [ amounts . length - 1 ] = amountOut ;  { uint256 i = path . length - 1 ;  while ( i > 0 ) { { uint256 [ ] memory reserves = uniswapV2Library_getReserves ( path [ i - 1 ] , path [ i ] , .TypedVals ) ;  amounts [ i - 1 ] = uniswapV2Library_getAmountIn ( amounts [ i ] , reserves [ 0 ] , reserves [ 1 ] , .TypedVals ) ;  .Statements }  i -- ;  .Statements }  .Statements }  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              uniswapV2Library_getAmountsOut
            </contract-fn-id>
            <contract-fn-visibility>
              private
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( uint256 )
              ListItem ( address [ ] )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( amountIn )
              ListItem ( path )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint256 [ ] )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( amounts )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              require ( path . length >= 2 , "UniswapV2Library: INVALID_PATH" , .TypedVals ) ;  amounts = new uint256 [ ] ( path . length , .TypedVals ) ;  amounts [ 0 ] = amountIn ;  { uint256 i ;  while ( i < path . length - 1 ) { { uint256 [ ] memory reserves = uniswapV2Library_getReserves ( path [ i ] , path [ i + 1 ] , .TypedVals ) ;  amounts [ i + 1 ] = uniswapV2Library_getAmountOut ( amounts [ i ] , reserves [ 0 ] , reserves [ 1 ] , .TypedVals ) ;  .Statements }  i ++ ;  .Statements }  .Statements }  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              uniswapV2Library_getReserves
            </contract-fn-id>
            <contract-fn-visibility>
              private
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( address )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( tokenA )
              ListItem ( tokenB )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint256 [ ] )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( reserves )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              reserves = new uint256 [ ] ( 2 , .TypedVals ) ;  address [ ] memory tokens = uniswapV2Library_sortTokens ( tokenA , tokenB , .TypedVals ) ;  uint112 [ ] memory pair_reserves = UniswapV2Pair ( uniswapV2Library_pairFor ( tokenA , tokenB , .TypedVals ) , .TypedVals ) . getReserves ( .TypedVals ) ;  reserves [ 0 ] = tokenA == tokens [ 0 ] ? pair_reserves [ 0 ] : pair_reserves [ 1 ] ;  reserves [ 1 ] = tokenA == tokens [ 0 ] ? pair_reserves [ 1 ] : pair_reserves [ 0 ] ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              uniswapV2Library_pairFor
            </contract-fn-id>
            <contract-fn-visibility>
              private
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( address )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( tokenA )
              ListItem ( tokenB )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( address )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( pair )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              address [ ] memory tokens = uniswapV2Library_sortTokens ( tokenA , tokenB , .TypedVals ) ;  pair = local_pairs [ tokens [ 0 ] ] [ tokens [ 1 ] ] ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              uniswapV2Library_quote
            </contract-fn-id>
            <contract-fn-visibility>
              internal
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( uint256 )
              ListItem ( uint256 )
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( amountA )
              ListItem ( reserveA )
              ListItem ( reserveB )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint256 )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( amountB )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              require ( amountA > 0 , "UniswapV2Library: INSUFFICIENT_AMOUNT" , .TypedVals ) ;  require ( reserveA > 0 && reserveB > 0 , "UniswapV2Library: INSUFFICIENT_LIQUIDITY" , .TypedVals ) ;  amountB = amountA * reserveB / reserveA ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              uniswapV2Library_sortTokens
            </contract-fn-id>
            <contract-fn-visibility>
              private
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( address )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( tokenA )
              ListItem ( tokenB )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( address [ ] )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( tokens )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              tokens = new address [ ] ( 2 , .TypedVals ) ;  require ( tokenA != tokenB , "UniswapV2Library: IDENTICAL_ADDRESSES" , .TypedVals ) ;  tokens [ 0 ] = tokenA < tokenB ? tokenA : tokenB ;  tokens [ 1 ] = tokenA < tokenB ? tokenB : tokenA ;  require ( tokens [ 0 ] != address ( 0 , .TypedVals ) , "UniswapV2Library: ZERO_ADDRESS" , .TypedVals ) ;  .Statements
            </contract-fn-body>
          </contract-fn>
        </contract-fns>
        <contract-events>
          .ContractEventCellMap
        </contract-events>
      </contract> <contract>
        <contract-id>
          UniswapV2Swap
        </contract-id>
        <contract-state>
          dai |-> IERC20
          router |-> UniswapV2Router02
          usdc |-> IERC20
          weth |-> IERC20
        </contract-state>
        <contract-init>
          .List
        </contract-init>
        <contract-fns>
          <contract-fn>
            <contract-fn-id>
              constructor
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( address )
              ListItem ( address )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( _weth )
              ListItem ( _dai )
              ListItem ( _usdc )
            </contract-fn-param-names>
            <contract-fn-return-types>
              .List
            </contract-fn-return-types>
            <contract-fn-return-names>
              .List
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              weth = IERC20 ( _weth , .TypedVals ) ;  dai = IERC20 ( _dai , .TypedVals ) ;  usdc = IERC20 ( _usdc , .TypedVals ) ;  router = new UniswapV2Router02 ( .TypedVals ) ;  router . set_local_pair ( _weth , _dai , .TypedVals ) ;  router . set_local_pair ( _weth , _usdc , .TypedVals ) ;  router . set_local_pair ( _usdc , _dai , .TypedVals ) ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              dai
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              .List
            </contract-fn-arg-types>
            <contract-fn-param-names>
              .List
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( IERC20 )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              return dai ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              router
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              .List
            </contract-fn-arg-types>
            <contract-fn-param-names>
              .List
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( UniswapV2Router02 )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              return router ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              swapMultiHopExactAmountIn
            </contract-fn-id>
            <contract-fn-visibility>
              external
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( uint256 )
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( amountIn )
              ListItem ( amountOutMin )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint256 )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( amountOut )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              dai . transferFrom ( msg . sender , address ( this , .TypedVals ) , amountIn , .TypedVals ) ;  dai . approve ( address ( router , .TypedVals ) , amountIn , .TypedVals ) ;  address [ ] memory path = new address [ ] ( 3 , .TypedVals ) ;  path [ 0 ] = address ( dai , .TypedVals ) ;  path [ 1 ] = address ( weth , .TypedVals ) ;  path [ 2 ] = address ( usdc , .TypedVals ) ;  uint256 [ ] memory amounts = router . swapExactTokensForTokens ( amountIn , amountOutMin , path , msg . sender , .TypedVals ) ;  return amounts [ 2 ] ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              swapMultiHopExactAmountOut
            </contract-fn-id>
            <contract-fn-visibility>
              external
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( uint256 )
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( amountOutDesired )
              ListItem ( amountInMax )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint256 )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( amountOut )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              dai . transferFrom ( msg . sender , address ( this , .TypedVals ) , amountInMax , .TypedVals ) ;  dai . approve ( address ( router , .TypedVals ) , amountInMax , .TypedVals ) ;  address [ ] memory path = new address [ ] ( 3 , .TypedVals ) ;  path [ 0 ] = address ( dai , .TypedVals ) ;  path [ 1 ] = address ( weth , .TypedVals ) ;  path [ 2 ] = address ( usdc , .TypedVals ) ;  uint256 [ ] memory amounts = router . swapTokensForExactTokens ( amountOutDesired , amountInMax , path , msg . sender , .TypedVals ) ;  if ( amounts [ 0 ] < amountInMax ) { dai . transfer ( msg . sender , amountInMax - amounts [ 0 ] , .TypedVals ) ;  .Statements }  return amounts [ 2 ] ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              swapSingleHopExactAmountIn
            </contract-fn-id>
            <contract-fn-visibility>
              external
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( uint256 )
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( amountIn )
              ListItem ( amountOutMin )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint256 )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( amountOut )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              weth . transferFrom ( msg . sender , address ( this , .TypedVals ) , amountIn , .TypedVals ) ;  weth . approve ( address ( router , .TypedVals ) , amountIn , .TypedVals ) ;  address [ ] memory path = new address [ ] ( 2 , .TypedVals ) ;  path [ 0 ] = address ( weth , .TypedVals ) ;  path [ 1 ] = address ( dai , .TypedVals ) ;  uint256 [ ] memory amounts = router . swapExactTokensForTokens ( amountIn , amountOutMin , path , msg . sender , .TypedVals ) ;  return amounts [ 1 ] ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              swapSingleHopExactAmountOut
            </contract-fn-id>
            <contract-fn-visibility>
              external
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( uint256 )
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( amountOutDesired )
              ListItem ( amountInMax )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint256 )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( amountOut )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              weth . transferFrom ( msg . sender , address ( this , .TypedVals ) , amountInMax , .TypedVals ) ;  weth . approve ( address ( router , .TypedVals ) , amountInMax , .TypedVals ) ;  address [ ] memory path = new address [ ] ( 2 , .TypedVals ) ;  path [ 0 ] = address ( weth , .TypedVals ) ;  path [ 1 ] = address ( dai , .TypedVals ) ;  uint256 [ ] memory amounts = router . swapTokensForExactTokens ( amountOutDesired , amountInMax , path , msg . sender , .TypedVals ) ;  if ( amounts [ 0 ] < amountInMax ) { weth . transfer ( msg . sender , amountInMax - amounts [ 0 ] , .TypedVals ) ;  .Statements }  return amounts [ 1 ] ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              usdc
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              .List
            </contract-fn-arg-types>
            <contract-fn-param-names>
              .List
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( IERC20 )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              return usdc ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              weth
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              .List
            </contract-fn-arg-types>
            <contract-fn-param-names>
              .List
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( IERC20 )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              return weth ;  .Statements
            </contract-fn-body>
          </contract-fn>
        </contract-fns>
        <contract-events>
          .ContractEventCellMap
        </contract-events>
      </contract> <contract>
        <contract-id>
          UniswapV2SwapTest
        </contract-id>
        <contract-state>
          _dai |-> DAIMock
          _uni |-> UniswapV2Swap
          _usdc |-> USDCMock
          _weth |-> WETHMock
        </contract-state>
        <contract-init>
          .List
        </contract-init>
        <contract-fns>
          <contract-fn>
            <contract-fn-id>
              setUp
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              .List
            </contract-fn-arg-types>
            <contract-fn-param-names>
              .List
            </contract-fn-param-names>
            <contract-fn-return-types>
              .List
            </contract-fn-return-types>
            <contract-fn-return-names>
              .List
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              _weth = new WETHMock ( .TypedVals ) ;  _dai = new DAIMock ( .TypedVals ) ;  _usdc = new USDCMock ( .TypedVals ) ;  _uni = new UniswapV2Swap ( address ( _weth , .TypedVals ) , address ( _dai , .TypedVals ) , address ( _usdc , .TypedVals ) , .TypedVals ) ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              testRouterAddLiquidity
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              .List
            </contract-fn-arg-types>
            <contract-fn-param-names>
              .List
            </contract-fn-param-names>
            <contract-fn-return-types>
              .List
            </contract-fn-return-types>
            <contract-fn-return-names>
              .List
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              uint256 testAmount = 131072 ;  uint256 desiredA = 10000 ;  uint256 desiredB = 10000 ;  uint256 minA = 0 ;  uint256 minB = 0 ;  UniswapV2Router02 _router = new UniswapV2Router02 ( .TypedVals ) ;  _router . set_local_pair ( address ( _weth , .TypedVals ) , address ( _dai , .TypedVals ) , .TypedVals ) ;  _router . set_local_pair ( address ( _weth , .TypedVals ) , address ( _usdc , .TypedVals ) , .TypedVals ) ;  _router . set_local_pair ( address ( _usdc , .TypedVals ) , address ( _dai , .TypedVals ) , .TypedVals ) ;  _dai . mint ( address ( this , .TypedVals ) , testAmount , .TypedVals ) ;  _dai . approve ( address ( _router , .TypedVals ) , testAmount , .TypedVals ) ;  _usdc . mint ( address ( this , .TypedVals ) , testAmount , .TypedVals ) ;  _usdc . approve ( address ( _router , .TypedVals ) , testAmount , .TypedVals ) ;  _router . addLiquidity ( address ( _dai , .TypedVals ) , address ( _usdc , .TypedVals ) , desiredA , desiredB , minA , minB , address ( this , .TypedVals ) , .TypedVals ) ;  assert ( _dai . balanceOf ( address ( this , .TypedVals ) , .TypedVals ) == 121072 , .TypedVals ) ;  assert ( _usdc . balanceOf ( address ( this , .TypedVals ) , .TypedVals ) == 121072 , .TypedVals ) ;  assert ( _dai . balanceOf ( _router . get_local_pair ( address ( _dai , .TypedVals ) , address ( _usdc , .TypedVals ) , .TypedVals ) , .TypedVals ) == 10000 , .TypedVals ) ;  assert ( _usdc . balanceOf ( _router . get_local_pair ( address ( _dai , .TypedVals ) , address ( _usdc , .TypedVals ) , .TypedVals ) , .TypedVals ) == 10000 , .TypedVals ) ;  assert ( UniswapV2Pair ( _router . get_local_pair ( address ( _dai , .TypedVals ) , address ( _usdc , .TypedVals ) , .TypedVals ) , .TypedVals ) . balanceOf ( address ( this , .TypedVals ) , .TypedVals ) == 9000 , .TypedVals ) ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              testSwapMultiHopExactAmountIn
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              .List
            </contract-fn-arg-types>
            <contract-fn-param-names>
              .List
            </contract-fn-param-names>
            <contract-fn-return-types>
              .List
            </contract-fn-return-types>
            <contract-fn-return-names>
              .List
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              uint256 wethAmount = 1e18 ;  _weth . deposit { value : 4 * wethAmount , .KeyValues } ( .TypedVals ) ;  _weth . approve ( address ( _uni , .TypedVals ) , 8 * wethAmount , .TypedVals ) ;  _dai . mint ( address ( this , .TypedVals ) , 3 * wethAmount , .TypedVals ) ;  _dai . approve ( address ( _uni , .TypedVals ) , 3 * wethAmount , .TypedVals ) ;  _usdc . mint ( address ( this , .TypedVals ) , 2 * wethAmount , .TypedVals ) ;  _usdc . approve ( address ( _uni , .TypedVals ) , 2 * wethAmount , .TypedVals ) ;  _weth . transfer ( _uni . router ( .TypedVals ) . get_local_pair ( address ( _weth , .TypedVals ) , address ( _dai , .TypedVals ) , .TypedVals ) , wethAmount , .TypedVals ) ;  _dai . transfer ( _uni . router ( .TypedVals ) . get_local_pair ( address ( _weth , .TypedVals ) , address ( _dai , .TypedVals ) , .TypedVals ) , wethAmount , .TypedVals ) ;  _uni . router ( .TypedVals ) . sync_local_pair ( address ( _weth , .TypedVals ) , address ( _dai , .TypedVals ) , .TypedVals ) ;  uint256 daiAmountMin = 1 ;  _uni . swapSingleHopExactAmountIn ( wethAmount , daiAmountMin , .TypedVals ) ;  uint256 daiAmountIn = 1e18 ;  _dai . transfer ( _uni . router ( .TypedVals ) . get_local_pair ( address ( _dai , .TypedVals ) , address ( _weth , .TypedVals ) , .TypedVals ) , daiAmountIn , .TypedVals ) ;  _weth . transfer ( _uni . router ( .TypedVals ) . get_local_pair ( address ( _dai , .TypedVals ) , address ( _weth , .TypedVals ) , .TypedVals ) , daiAmountIn , .TypedVals ) ;  _weth . transfer ( _uni . router ( .TypedVals ) . get_local_pair ( address ( _weth , .TypedVals ) , address ( _usdc , .TypedVals ) , .TypedVals ) , daiAmountIn , .TypedVals ) ;  _usdc . transfer ( _uni . router ( .TypedVals ) . get_local_pair ( address ( _weth , .TypedVals ) , address ( _usdc , .TypedVals ) , .TypedVals ) , daiAmountIn , .TypedVals ) ;  _uni . router ( .TypedVals ) . sync_local_pair ( address ( _dai , .TypedVals ) , address ( _weth , .TypedVals ) , .TypedVals ) ;  _uni . router ( .TypedVals ) . sync_local_pair ( address ( _weth , .TypedVals ) , address ( _usdc , .TypedVals ) , .TypedVals ) ;  uint256 usdcAmountOutMin = 1 ;  uint256 usdcAmountOut = _uni . swapMultiHopExactAmountIn ( daiAmountIn , usdcAmountOutMin , .TypedVals ) ;  assert ( usdcAmountOut >= usdcAmountOutMin , .TypedVals ) ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              testSwapMultiHopExactAmountOut
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              .List
            </contract-fn-arg-types>
            <contract-fn-param-names>
              .List
            </contract-fn-param-names>
            <contract-fn-return-types>
              .List
            </contract-fn-return-types>
            <contract-fn-return-names>
              .List
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              uint256 wethAmount = 1e18 ;  _weth . deposit { value : 20 * wethAmount , .KeyValues } ( .TypedVals ) ;  _weth . approve ( address ( _uni , .TypedVals ) , 20 * wethAmount , .TypedVals ) ;  _dai . mint ( address ( this , .TypedVals ) , 20 * wethAmount , .TypedVals ) ;  _dai . approve ( address ( _uni , .TypedVals ) , 20 * wethAmount , .TypedVals ) ;  _usdc . mint ( address ( this , .TypedVals ) , 10 * wethAmount , .TypedVals ) ;  _usdc . approve ( address ( _uni , .TypedVals ) , 10 * wethAmount , .TypedVals ) ;  _weth . transfer ( _uni . router ( .TypedVals ) . get_local_pair ( address ( _weth , .TypedVals ) , address ( _dai , .TypedVals ) , .TypedVals ) , 8 * wethAmount , .TypedVals ) ;  _dai . transfer ( _uni . router ( .TypedVals ) . get_local_pair ( address ( _weth , .TypedVals ) , address ( _dai , .TypedVals ) , .TypedVals ) , 8 * wethAmount , .TypedVals ) ;  _uni . router ( .TypedVals ) . sync_local_pair ( address ( _weth , .TypedVals ) , address ( _dai , .TypedVals ) , .TypedVals ) ;  uint256 daiAmountOut = 2 * 1e18 ;  _uni . swapSingleHopExactAmountOut ( daiAmountOut , 4 * wethAmount , .TypedVals ) ;  _dai . transfer ( _uni . router ( .TypedVals ) . get_local_pair ( address ( _dai , .TypedVals ) , address ( _weth , .TypedVals ) , .TypedVals ) , 2 * daiAmountOut , .TypedVals ) ;  _weth . transfer ( _uni . router ( .TypedVals ) . get_local_pair ( address ( _dai , .TypedVals ) , address ( _weth , .TypedVals ) , .TypedVals ) , 2 * daiAmountOut , .TypedVals ) ;  _weth . transfer ( _uni . router ( .TypedVals ) . get_local_pair ( address ( _weth , .TypedVals ) , address ( _usdc , .TypedVals ) , .TypedVals ) , 2 * daiAmountOut , .TypedVals ) ;  _usdc . transfer ( _uni . router ( .TypedVals ) . get_local_pair ( address ( _weth , .TypedVals ) , address ( _usdc , .TypedVals ) , .TypedVals ) , 2 * daiAmountOut , .TypedVals ) ;  _uni . router ( .TypedVals ) . sync_local_pair ( address ( _dai , .TypedVals ) , address ( _weth , .TypedVals ) , .TypedVals ) ;  _uni . router ( .TypedVals ) . sync_local_pair ( address ( _weth , .TypedVals ) , address ( _usdc , .TypedVals ) , .TypedVals ) ;  uint256 amountOutDesired = 1e6 ;  uint256 amountOut = _uni . swapMultiHopExactAmountOut ( amountOutDesired , daiAmountOut , .TypedVals ) ;  assert ( amountOut == amountOutDesired , .TypedVals ) ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              testSwapSingleHopExactAmountIn
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              .List
            </contract-fn-arg-types>
            <contract-fn-param-names>
              .List
            </contract-fn-param-names>
            <contract-fn-return-types>
              .List
            </contract-fn-return-types>
            <contract-fn-return-names>
              .List
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              uint256 wethAmount = 1e18 ;  _weth . deposit { value : 2 * wethAmount , .KeyValues } ( .TypedVals ) ;  _weth . approve ( address ( _uni , .TypedVals ) , 2 * wethAmount , .TypedVals ) ;  _dai . mint ( address ( this , .TypedVals ) , wethAmount , .TypedVals ) ;  _dai . approve ( address ( _uni , .TypedVals ) , wethAmount , .TypedVals ) ;  _weth . transfer ( _uni . router ( .TypedVals ) . get_local_pair ( address ( _weth , .TypedVals ) , address ( _dai , .TypedVals ) , .TypedVals ) , wethAmount , .TypedVals ) ;  _dai . transfer ( _uni . router ( .TypedVals ) . get_local_pair ( address ( _weth , .TypedVals ) , address ( _dai , .TypedVals ) , .TypedVals ) , wethAmount , .TypedVals ) ;  _uni . router ( .TypedVals ) . sync_local_pair ( address ( _weth , .TypedVals ) , address ( _dai , .TypedVals ) , .TypedVals ) ;  uint256 daiAmountMin = 1 ;  uint256 daiAmountOut = _uni . swapSingleHopExactAmountIn ( wethAmount , daiAmountMin , .TypedVals ) ;  assert ( daiAmountOut >= daiAmountMin , .TypedVals ) ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              testSwapSingleHopExactAmountOut
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              .List
            </contract-fn-arg-types>
            <contract-fn-param-names>
              .List
            </contract-fn-param-names>
            <contract-fn-return-types>
              .List
            </contract-fn-return-types>
            <contract-fn-return-names>
              .List
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              uint256 wethAmount = 1e18 ;  _weth . deposit { value : 10 * wethAmount , .KeyValues } ( .TypedVals ) ;  _weth . approve ( address ( _uni , .TypedVals ) , 6 * wethAmount , .TypedVals ) ;  _dai . mint ( address ( this , .TypedVals ) , 10 * wethAmount , .TypedVals ) ;  _dai . approve ( address ( _uni , .TypedVals ) , 4 * wethAmount , .TypedVals ) ;  _weth . transfer ( _uni . router ( .TypedVals ) . get_local_pair ( address ( _weth , .TypedVals ) , address ( _dai , .TypedVals ) , .TypedVals ) , 4 * wethAmount , .TypedVals ) ;  _dai . transfer ( _uni . router ( .TypedVals ) . get_local_pair ( address ( _weth , .TypedVals ) , address ( _dai , .TypedVals ) , .TypedVals ) , 4 * wethAmount , .TypedVals ) ;  _uni . router ( .TypedVals ) . sync_local_pair ( address ( _weth , .TypedVals ) , address ( _dai , .TypedVals ) , .TypedVals ) ;  uint256 daiAmountDesired = 1e18 ;  uint256 daiAmountOut = _uni . swapSingleHopExactAmountOut ( daiAmountDesired , 2 * wethAmount , .TypedVals ) ;  assert ( daiAmountOut == daiAmountDesired , .TypedVals ) ;  .Statements
            </contract-fn-body>
          </contract-fn>
        </contract-fns>
        <contract-events>
          .ContractEventCellMap
        </contract-events>
      </contract> <contract>
        <contract-id>
          WETHMock
        </contract-id>
        <contract-state>
          UINT256_MAX |-> uint256
          allowance |-> mapping ( address  => mapping ( address  => uint256  )  )
          balanceOf |-> mapping ( address  => uint256  )
        </contract-state>
        <contract-init>
          ListItem ( UINT256_MAX = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ; )
        </contract-init>
        <contract-fns>
          <contract-fn>
            <contract-fn-id>
              allowance
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( address )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( $0 )
              ListItem ( $1 )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( mapping ( address  => mapping ( address  => uint256  )  ) )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              return allowance [ $0 ] [ $1 ] ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              approve
            </contract-fn-id>
            <contract-fn-visibility>
              external
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( spender )
              ListItem ( value )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( bool )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              allowance [ msg . sender ] [ spender ] = value ;  emit Approval ( msg . sender , spender , value , .TypedVals ) ;  return true ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              balanceOf
            </contract-fn-id>
            <contract-fn-visibility>
              public
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( $0 )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( mapping ( address  => uint256  ) )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              return balanceOf [ $0 ] ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              decimals
            </contract-fn-id>
            <contract-fn-visibility>
              external
            </contract-fn-visibility>
            <contract-fn-arg-types>
              .List
            </contract-fn-arg-types>
            <contract-fn-param-names>
              .List
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( uint8 )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              return 18 ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              deposit
            </contract-fn-id>
            <contract-fn-visibility>
              external
            </contract-fn-visibility>
            <contract-fn-arg-types>
              .List
            </contract-fn-arg-types>
            <contract-fn-param-names>
              .List
            </contract-fn-param-names>
            <contract-fn-return-types>
              .List
            </contract-fn-return-types>
            <contract-fn-return-names>
              .List
            </contract-fn-return-names>
            <contract-fn-payable>
              true
            </contract-fn-payable>
            <contract-fn-body>
              balanceOf [ msg . sender ] = balanceOf [ msg . sender ] + msg . value ;  emit Transfer ( address ( 0 , .TypedVals ) , msg . sender , msg . value , .TypedVals ) ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              transfer
            </contract-fn-id>
            <contract-fn-visibility>
              external
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( to )
              ListItem ( value )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( bool )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              if ( to != address ( 0 , .TypedVals ) && to != address ( this , .TypedVals ) ) { uint256 balance = balanceOf [ msg . sender ] ;  require ( balance >= value , "WETH: transfer amount exceeds balance" , .TypedVals ) ;  balanceOf [ msg . sender ] = balance - value ;  balanceOf [ to ] = balanceOf [ to ] + value ;  emit Transfer ( msg . sender , to , value , .TypedVals ) ;  .Statements } else { uint256 balance = balanceOf [ msg . sender ] ;  require ( balance >= value , "WETH: burn amount exceeds balance" , .TypedVals ) ;  balanceOf [ msg . sender ] = balance - value ;  emit Transfer ( msg . sender , address ( 0 , .TypedVals ) , value , .TypedVals ) ;  ( bool success , ) = msg . sender . call { value : value , .KeyValues } ( "" , .TypedVals ) ;  require ( success , "WETH: ETH transfer failed" , .TypedVals ) ;  .Statements }  return true ;  .Statements
            </contract-fn-body>
          </contract-fn> <contract-fn>
            <contract-fn-id>
              transferFrom
            </contract-fn-id>
            <contract-fn-visibility>
              external
            </contract-fn-visibility>
            <contract-fn-arg-types>
              ListItem ( address )
              ListItem ( address )
              ListItem ( uint256 )
            </contract-fn-arg-types>
            <contract-fn-param-names>
              ListItem ( from )
              ListItem ( to )
              ListItem ( value )
            </contract-fn-param-names>
            <contract-fn-return-types>
              ListItem ( bool )
            </contract-fn-return-types>
            <contract-fn-return-names>
              ListItem ( noId )
            </contract-fn-return-names>
            <contract-fn-payable>
              false
            </contract-fn-payable>
            <contract-fn-body>
              if ( from != msg . sender ) { uint256 allowed = allowance [ from ] [ msg . sender ] ;  if ( allowed != UINT256_MAX ) { require ( allowed >= value , "WETH: request exceeds allowance" , .TypedVals ) ;  uint256 reduced = allowed - value ;  allowance [ from ] [ msg . sender ] = reduced ;  emit Approval ( from , msg . sender , reduced , .TypedVals ) ;  .Statements }  .Statements }  if ( to != address ( 0 , .TypedVals ) && to != address ( this , .TypedVals ) ) { uint256 balance = balanceOf [ from ] ;  require ( balance >= value , "WETH: transfer amount exceeds balance" , .TypedVals ) ;  balanceOf [ from ] = balance - value ;  balanceOf [ to ] = balanceOf [ to ] + value ;  emit Transfer ( from , to , value , .TypedVals ) ;  .Statements } else { uint256 balance = balanceOf [ from ] ;  require ( balance >= value , "WETH: burn amount exceeds balance" , .TypedVals ) ;  balanceOf [ from ] = balance - value ;  emit Transfer ( from , address ( 0 , .TypedVals ) , value , .TypedVals ) ;  ( bool success , ) = msg . sender . call { value : value , .KeyValues } ( "" , .TypedVals ) ;  require ( success , "WETH: ETH transfer failed" , .TypedVals ) ;  .Statements }  return true ;  .Statements
            </contract-fn-body>
          </contract-fn>
        </contract-fns>
        <contract-events>
          <contract-event>
            <contract-event-id>
              Approval
            </contract-event-id>
            <contract-event-arg-types>
              ListItem ( address )
              ListItem ( address )
              ListItem ( uint256 )
            </contract-event-arg-types>
            <contract-event-param-names>
              ListItem ( owner )
              ListItem ( spender )
              ListItem ( value )
            </contract-event-param-names>
            <contract-event-indexed-pos>
              SetItem ( 0 )
              SetItem ( 1 )
            </contract-event-indexed-pos>
          </contract-event> <contract-event>
            <contract-event-id>
              Transfer
            </contract-event-id>
            <contract-event-arg-types>
              ListItem ( address )
              ListItem ( address )
              ListItem ( uint256 )
            </contract-event-arg-types>
            <contract-event-param-names>
              ListItem ( from )
              ListItem ( to )
              ListItem ( value )
            </contract-event-param-names>
            <contract-event-indexed-pos>
              SetItem ( 0 )
              SetItem ( 1 )
            </contract-event-indexed-pos>
          </contract-event>
        </contract-events>
      </contract>
    </contracts>
  </compile>
  <exec>
    <msg-sender>
      1p160
    </msg-sender>
    <msg-value>
      0p256
    </msg-value>
    <tx-origin>
      1p160
    </tx-origin>
    <block-timestamp>
      1724300000p256
    </block-timestamp>
    <this>
      2p160
    </this>
    <this-type>
      UniswapV2SwapTest
    </this-type>
    <env>
      _router |-> var ( 1300 , UniswapV2Router02 )
      desiredA |-> var ( 1296 , uint256 )
      desiredB |-> var ( 1297 , uint256 )
      minA |-> var ( 1298 , uint256 )
      minB |-> var ( 1299 , uint256 )
      testAmount |-> var ( 1295 , uint256 )
    </env>
    <store>
      1295 |-> 131072p256
      1296 |-> 10000p256
      1297 |-> 10000p256
      1298 |-> 0p256
      1299 |-> 0p256
      1300 |-> 43p160
    </store>
    <call-stack>
      .List
    </call-stack>
    <live-contracts>
      <live-contract>
        <contract-address>
          2p160
        </contract-address>
        <contract-type>
          UniswapV2SwapTest
        </contract-type>
        <contract-storage>
          _dai |-> 36p160
          _uni |-> 38p160
          _usdc |-> 37p160
          _weth |-> 35p160
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          3p160
        </contract-address>
        <contract-type>
          WETHMock
        </contract-type>
        <contract-storage>
          UINT256_MAX |-> 115792089237316195423570985008687907853269984665640564039457584007913129639935p256
          allowance |-> ( 2p160 |-> ( 6p160 |-> 1000000000000000000p256 )
          6p160 |-> ( 7p160 |-> 0p256 ) )
          balanceOf |-> ( 2p160 |-> 0p256
          6p160 |-> 0p256
          8p160 |-> 2000000000000000000p256 )
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          4p160
        </contract-address>
        <contract-type>
          DAIMock
        </contract-type>
        <contract-storage>
          UINT_MAX |-> 115792089237316195423570985008687907853269984665640564039457584007913129639935p256
          allowance |-> ( 2p160 |-> ( 6p160 |-> 1000000000000000000p256 ) )
          balanceOf |-> ( 2p160 |-> 499248873309964947p256
          8p160 |-> 500751126690035053p256 )
          totalSupply |-> 1000000000000000000p256
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          5p160
        </contract-address>
        <contract-type>
          USDCMock
        </contract-type>
        <contract-storage>
          UINT256_MAX |-> 115792089237316195423570985008687907853269984665640564039457584007913129639935p256
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          6p160
        </contract-address>
        <contract-type>
          UniswapV2Swap
        </contract-type>
        <contract-storage>
          dai |-> 4p160
          router |-> 7p160
          usdc |-> 5p160
          weth |-> 3p160
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          7p160
        </contract-address>
        <contract-type>
          UniswapV2Router02
        </contract-type>
        <contract-storage>
          local_pairs |-> ( 3p160 |-> ( 4p160 |-> 8p160
          5p160 |-> 9p160 )
          4p160 |-> ( 5p160 |-> 10p160 ) )
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          8p160
        </contract-address>
        <contract-type>
          UniswapV2Pair
        </contract-type>
        <contract-storage>
          MINIMUM_LIQUIDITY |-> 1000p256
          UINT112_MAX |-> 5192296858534827628530496329220095p256
          blockTimestampLast |-> 1724300000p32
          reserve0 |-> 2000000000000000000p112
          reserve1 |-> 500751126690035053p112
          token0 |-> 3p160
          token1 |-> 4p160
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          9p160
        </contract-address>
        <contract-type>
          UniswapV2Pair
        </contract-type>
        <contract-storage>
          MINIMUM_LIQUIDITY |-> 1000p256
          UINT112_MAX |-> 5192296858534827628530496329220095p256
          token0 |-> 3p160
          token1 |-> 5p160
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          10p160
        </contract-address>
        <contract-type>
          UniswapV2Pair
        </contract-type>
        <contract-storage>
          MINIMUM_LIQUIDITY |-> 1000p256
          UINT112_MAX |-> 5192296858534827628530496329220095p256
          token0 |-> 4p160
          token1 |-> 5p160
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          11p160
        </contract-address>
        <contract-type>
          WETHMock
        </contract-type>
        <contract-storage>
          UINT256_MAX |-> 115792089237316195423570985008687907853269984665640564039457584007913129639935p256
          allowance |-> ( 2p160 |-> ( 14p160 |-> 7000000000000000000p256 )
          14p160 |-> ( 15p160 |-> 0p256 ) )
          balanceOf |-> ( 2p160 |-> 0p256
          14p160 |-> 0p256
          16p160 |-> 1802522810203429866p256
          17p160 |-> 2197477189796570134p256 )
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          12p160
        </contract-address>
        <contract-type>
          DAIMock
        </contract-type>
        <contract-storage>
          UINT_MAX |-> 115792089237316195423570985008687907853269984665640564039457584007913129639935p256
          allowance |-> ( 2p160 |-> ( 14p160 |-> 2000000000000000000p256 )
          14p160 |-> ( 15p160 |-> 0p256 ) )
          balanceOf |-> ( 2p160 |-> 499248873309964947p256
          14p160 |-> 0p256
          16p160 |-> 2500751126690035053p256 )
          totalSupply |-> 3000000000000000000p256
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          13p160
        </contract-address>
        <contract-type>
          USDCMock
        </contract-type>
        <contract-storage>
          UINT256_MAX |-> 115792089237316195423570985008687907853269984665640564039457584007913129639935p256
          _allowances |-> ( 2p160 |-> ( 14p160 |-> 2000000000000000000p256 ) )
          _balances |-> ( 2p160 |-> 1544187543921826939p256
          17p160 |-> 455812456078173061p256 )
          _totalSupply |-> 2000000000000000000p256
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          14p160
        </contract-address>
        <contract-type>
          UniswapV2Swap
        </contract-type>
        <contract-storage>
          dai |-> 12p160
          router |-> 15p160
          usdc |-> 13p160
          weth |-> 11p160
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          15p160
        </contract-address>
        <contract-type>
          UniswapV2Router02
        </contract-type>
        <contract-storage>
          local_pairs |-> ( 11p160 |-> ( 12p160 |-> 16p160
          13p160 |-> 17p160 )
          12p160 |-> ( 13p160 |-> 18p160 ) )
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          16p160
        </contract-address>
        <contract-type>
          UniswapV2Pair
        </contract-type>
        <contract-storage>
          MINIMUM_LIQUIDITY |-> 1000p256
          UINT112_MAX |-> 5192296858534827628530496329220095p256
          blockTimestampLast |-> 1724300000p32
          reserve0 |-> 1802522810203429866p112
          reserve1 |-> 2500751126690035053p112
          token0 |-> 11p160
          token1 |-> 12p160
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          17p160
        </contract-address>
        <contract-type>
          UniswapV2Pair
        </contract-type>
        <contract-storage>
          MINIMUM_LIQUIDITY |-> 1000p256
          UINT112_MAX |-> 5192296858534827628530496329220095p256
          blockTimestampLast |-> 1724300000p32
          reserve0 |-> 2197477189796570134p112
          reserve1 |-> 455812456078173061p112
          token0 |-> 11p160
          token1 |-> 13p160
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          18p160
        </contract-address>
        <contract-type>
          UniswapV2Pair
        </contract-type>
        <contract-storage>
          MINIMUM_LIQUIDITY |-> 1000p256
          UINT112_MAX |-> 5192296858534827628530496329220095p256
          token0 |-> 12p160
          token1 |-> 13p160
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          19p160
        </contract-address>
        <contract-type>
          WETHMock
        </contract-type>
        <contract-storage>
          UINT256_MAX |-> 115792089237316195423570985008687907853269984665640564039457584007913129639935p256
          allowance |-> ( 2p160 |-> ( 22p160 |-> 4000000000000000000p256 )
          22p160 |-> ( 23p160 |-> 662654630558341691p256 ) )
          balanceOf |-> ( 2p160 |-> 4662654630558341691p256
          22p160 |-> 0p256
          24p160 |-> 5337345369441658309p256 )
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          20p160
        </contract-address>
        <contract-type>
          DAIMock
        </contract-type>
        <contract-storage>
          UINT_MAX |-> 115792089237316195423570985008687907853269984665640564039457584007913129639935p256
          allowance |-> ( 2p160 |-> ( 22p160 |-> 4000000000000000000p256 ) )
          balanceOf |-> ( 2p160 |-> 7000000000000000000p256
          24p160 |-> 3000000000000000000p256 )
          totalSupply |-> 10000000000000000000p256
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          21p160
        </contract-address>
        <contract-type>
          USDCMock
        </contract-type>
        <contract-storage>
          UINT256_MAX |-> 115792089237316195423570985008687907853269984665640564039457584007913129639935p256
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          22p160
        </contract-address>
        <contract-type>
          UniswapV2Swap
        </contract-type>
        <contract-storage>
          dai |-> 20p160
          router |-> 23p160
          usdc |-> 21p160
          weth |-> 19p160
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          23p160
        </contract-address>
        <contract-type>
          UniswapV2Router02
        </contract-type>
        <contract-storage>
          local_pairs |-> ( 19p160 |-> ( 20p160 |-> 24p160
          21p160 |-> 25p160 )
          20p160 |-> ( 21p160 |-> 26p160 ) )
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          24p160
        </contract-address>
        <contract-type>
          UniswapV2Pair
        </contract-type>
        <contract-storage>
          MINIMUM_LIQUIDITY |-> 1000p256
          UINT112_MAX |-> 5192296858534827628530496329220095p256
          blockTimestampLast |-> 1724300000p32
          reserve0 |-> 5337345369441658309p112
          reserve1 |-> 3000000000000000000p112
          token0 |-> 19p160
          token1 |-> 20p160
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          25p160
        </contract-address>
        <contract-type>
          UniswapV2Pair
        </contract-type>
        <contract-storage>
          MINIMUM_LIQUIDITY |-> 1000p256
          UINT112_MAX |-> 5192296858534827628530496329220095p256
          token0 |-> 19p160
          token1 |-> 21p160
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          26p160
        </contract-address>
        <contract-type>
          UniswapV2Pair
        </contract-type>
        <contract-storage>
          MINIMUM_LIQUIDITY |-> 1000p256
          UINT112_MAX |-> 5192296858534827628530496329220095p256
          token0 |-> 20p160
          token1 |-> 21p160
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          27p160
        </contract-address>
        <contract-type>
          WETHMock
        </contract-type>
        <contract-storage>
          UINT256_MAX |-> 115792089237316195423570985008687907853269984665640564039457584007913129639935p256
          allowance |-> ( 2p160 |-> ( 30p160 |-> 16000000000000000000p256 )
          30p160 |-> ( 31p160 |-> 1325309261116683383p256 ) )
          balanceOf |-> ( 2p160 |-> 1325309261116683383p256
          30p160 |-> 0p256
          32p160 |-> 14674690738882313607p256
          33p160 |-> 4000000000001003010p256 )
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          28p160
        </contract-address>
        <contract-type>
          DAIMock
        </contract-type>
        <contract-storage>
          UINT_MAX |-> 115792089237316195423570985008687907853269984665640564039457584007913129639935p256
          allowance |-> ( 2p160 |-> ( 30p160 |-> 18000000000000000000p256 )
          30p160 |-> ( 31p160 |-> 1999999999999314446p256 ) )
          balanceOf |-> ( 2p160 |-> 9999999999999314446p256
          30p160 |-> 0p256
          32p160 |-> 10000000000000685554p256 )
          totalSupply |-> 20000000000000000000p256
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          29p160
        </contract-address>
        <contract-type>
          USDCMock
        </contract-type>
        <contract-storage>
          UINT256_MAX |-> 115792089237316195423570985008687907853269984665640564039457584007913129639935p256
          _allowances |-> ( 2p160 |-> ( 30p160 |-> 10000000000000000000p256 ) )
          _balances |-> ( 2p160 |-> 6000000000001000000p256
          33p160 |-> 3999999999999000000p256 )
          _totalSupply |-> 10000000000000000000p256
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          30p160
        </contract-address>
        <contract-type>
          UniswapV2Swap
        </contract-type>
        <contract-storage>
          dai |-> 28p160
          router |-> 31p160
          usdc |-> 29p160
          weth |-> 27p160
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          31p160
        </contract-address>
        <contract-type>
          UniswapV2Router02
        </contract-type>
        <contract-storage>
          local_pairs |-> ( 27p160 |-> ( 28p160 |-> 32p160
          29p160 |-> 33p160 )
          28p160 |-> ( 29p160 |-> 34p160 ) )
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          32p160
        </contract-address>
        <contract-type>
          UniswapV2Pair
        </contract-type>
        <contract-storage>
          MINIMUM_LIQUIDITY |-> 1000p256
          UINT112_MAX |-> 5192296858534827628530496329220095p256
          blockTimestampLast |-> 1724300000p32
          reserve0 |-> 14674690738882313607p112
          reserve1 |-> 10000000000000685554p112
          token0 |-> 27p160
          token1 |-> 28p160
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          33p160
        </contract-address>
        <contract-type>
          UniswapV2Pair
        </contract-type>
        <contract-storage>
          MINIMUM_LIQUIDITY |-> 1000p256
          UINT112_MAX |-> 5192296858534827628530496329220095p256
          blockTimestampLast |-> 1724300000p32
          reserve0 |-> 4000000000001003010p112
          reserve1 |-> 3999999999999000000p112
          token0 |-> 27p160
          token1 |-> 29p160
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          34p160
        </contract-address>
        <contract-type>
          UniswapV2Pair
        </contract-type>
        <contract-storage>
          MINIMUM_LIQUIDITY |-> 1000p256
          UINT112_MAX |-> 5192296858534827628530496329220095p256
          token0 |-> 28p160
          token1 |-> 29p160
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          35p160
        </contract-address>
        <contract-type>
          WETHMock
        </contract-type>
        <contract-storage>
          UINT256_MAX |-> 115792089237316195423570985008687907853269984665640564039457584007913129639935p256
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          36p160
        </contract-address>
        <contract-type>
          DAIMock
        </contract-type>
        <contract-storage>
          UINT_MAX |-> 115792089237316195423570985008687907853269984665640564039457584007913129639935p256
          allowance |-> ( 2p160 |-> ( 43p160 |-> 121072p256 ) )
          balanceOf |-> ( 2p160 |-> 121072p256
          46p160 |-> 10000p256 )
          totalSupply |-> 131072p256
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          37p160
        </contract-address>
        <contract-type>
          USDCMock
        </contract-type>
        <contract-storage>
          UINT256_MAX |-> 115792089237316195423570985008687907853269984665640564039457584007913129639935p256
          _allowances |-> ( 2p160 |-> ( 43p160 |-> 121072p256 ) )
          _balances |-> ( 2p160 |-> 121072p256
          46p160 |-> 10000p256 )
          _totalSupply |-> 131072p256
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          38p160
        </contract-address>
        <contract-type>
          UniswapV2Swap
        </contract-type>
        <contract-storage>
          dai |-> 36p160
          router |-> 39p160
          usdc |-> 37p160
          weth |-> 35p160
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          39p160
        </contract-address>
        <contract-type>
          UniswapV2Router02
        </contract-type>
        <contract-storage>
          local_pairs |-> ( 35p160 |-> ( 36p160 |-> 40p160
          37p160 |-> 41p160 )
          36p160 |-> ( 37p160 |-> 42p160 ) )
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          40p160
        </contract-address>
        <contract-type>
          UniswapV2Pair
        </contract-type>
        <contract-storage>
          MINIMUM_LIQUIDITY |-> 1000p256
          UINT112_MAX |-> 5192296858534827628530496329220095p256
          token0 |-> 35p160
          token1 |-> 36p160
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          41p160
        </contract-address>
        <contract-type>
          UniswapV2Pair
        </contract-type>
        <contract-storage>
          MINIMUM_LIQUIDITY |-> 1000p256
          UINT112_MAX |-> 5192296858534827628530496329220095p256
          token0 |-> 35p160
          token1 |-> 37p160
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          42p160
        </contract-address>
        <contract-type>
          UniswapV2Pair
        </contract-type>
        <contract-storage>
          MINIMUM_LIQUIDITY |-> 1000p256
          UINT112_MAX |-> 5192296858534827628530496329220095p256
          token0 |-> 36p160
          token1 |-> 37p160
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          43p160
        </contract-address>
        <contract-type>
          UniswapV2Router02
        </contract-type>
        <contract-storage>
          local_pairs |-> ( 35p160 |-> ( 36p160 |-> 44p160
          37p160 |-> 45p160 )
          36p160 |-> ( 37p160 |-> 46p160 ) )
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          44p160
        </contract-address>
        <contract-type>
          UniswapV2Pair
        </contract-type>
        <contract-storage>
          MINIMUM_LIQUIDITY |-> 1000p256
          UINT112_MAX |-> 5192296858534827628530496329220095p256
          token0 |-> 35p160
          token1 |-> 36p160
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          45p160
        </contract-address>
        <contract-type>
          UniswapV2Pair
        </contract-type>
        <contract-storage>
          MINIMUM_LIQUIDITY |-> 1000p256
          UINT112_MAX |-> 5192296858534827628530496329220095p256
          token0 |-> 35p160
          token1 |-> 37p160
        </contract-storage>
      </live-contract> <live-contract>
        <contract-address>
          46p160
        </contract-address>
        <contract-type>
          UniswapV2Pair
        </contract-type>
        <contract-storage>
          MINIMUM_LIQUIDITY |-> 1000p256
          UINT112_MAX |-> 5192296858534827628530496329220095p256
          balanceOf |-> ( 0p160 |-> 1000p256
          2p160 |-> 9000p256 )
          blockTimestampLast |-> 1724300000p32
          reserve0 |-> 10000p112
          reserve1 |-> 10000p112
          token0 |-> 36p160
          token1 |-> 37p160
          totalSupply |-> 10000p256
        </contract-storage>
      </live-contract>
    </live-contracts>
    <next-address>
      47p160
    </next-address>
  </exec>
</solidity>
